# data.ver <- "FULL"
data.ver <- "13"
size <- 1178
#size <-200
# set.seed(2134)
rm(.Random.seed, envir=.GlobalEnv)
plas <- make.set(ver=data.ver, size = size, plas = plas_org, use.subset=F)
plas.formula <- make.formula("Y5", "A1", ver=data.ver)
outForm <- plas.formula$outForm
expForm <- plas.formula$expForm
plas_sim_N <- 1000
Effect_Size <- 6.6 # simulated risk difference = large change (e.g. absolute units)
#Effect_Size <- 0.66 # simulated risk difference = 2/3 SD higher BMI
source("20200226-PlasmodeCont_Revised.R")
# set.seed(2222)
plas_sims <- PlasmodeContNew(formulaOut = as.formula(outForm), objectOut = NULL,
formulaExp = as.formula(expForm), objectExp = NULL,
data = plas, idVar = "id",
effectOR = Effect_Size, MMOut = 1, MMExp = 1,
nsim = plas_sim_N, size = nrow(plas),
exposedPrev = NULL)
}
#meta_res <- NULL # intialize the results table
source("20200705-DCDR-Functions.R")
source("20200720-Algos-code.R")
##################################
## PARALLELIZE ANALYSES
##################################
{
##########################################
# Initialize necessary parameters for estimator
##########################################
# TMLE parameters
#SL.lib <- c("SL.randomForest", "SL.xgboost", "SL.nnet", "SL.glm", "SL.glmnet", "SL.polymars")
#SL.lib <- list("SL.randomForest", "SL.xgboost", "SL.nnet", "SL.glm", c("SL.glmnet", "All"), c("SL.polymars", "All"))
SL.lib <- list("SL.randomForest", "SL.xgboost", "SL.glm", c("SL.polymars", "All"))
SL.lib.tmle <- c("SL.randomForest", "SL.xgboost", "SL.glm", "SL.polymars")
SL.param <- c("SL.glm", "SL.glmnet", "SL.polymars")
# Specify the NP-SEM for the TMLE - including bounded, tranformed Y ("YT")
Zvars <- ifelse(data.ver=="FULL",
vars,
c("L0.a", "L0.b", "L0.c", "L0.d", "L0.e", "L0.f", "L0.g", "L0.h", "L0.i", "L0.j", "L0.k"))
npsem <- list(define_node("Z", Zvars),
#c("L0.a", "L0.b", "L0.c", "L0.d", "L0.e", "L0.f", "L0.g", "L0.h", "L0.i", "L0.j", "L0.k")),
define_node("A", c("A"), c("Z")),
define_node("Y", c("YT"), c("A", "Z")))
# Specify the learners for CV-TMLE
lrnr_SL <- make_learner(Lrnr_pkg_SuperLearner, SL.lib.tmle)
lrnr_SL_param <- make_learner(Lrnr_pkg_SuperLearner, SL.param)
lrnr_glm <- make_learner(Lrnr_glm_fast)
lrnr_mean <- make_learner(Lrnr_mean)
SL_list <- list(Y = lrnr_SL, A = lrnr_SL)
SL_param_list <- list(Y = lrnr_SL_param, A = lrnr_SL_param)
glm_list <- list(Y = lrnr_glm, A = lrnr_glm)
}
{
set.seed(42782)
tic()
N_sims <- 200# this should <= plas_sim_N
# regression models for GLM / AIPW
reg.formulas <- make.formula("Y", "A",ver = data.ver)
expForm <- reg.formulas$expForm
outForm <- reg.formulas$outForm
# # specify which set of learners for SL
# ### NON-SMOOTH
# short_tmle_lib <- SL_param_list
# tmle_lib <- lrnr_SL
# aipw_lib <- SL.lib
#### SMOOTH
short_tmle_lib <- SL_list
tmle_lib <- lrnr_SL_param
aipw_lib <- SL.param
boot1 <- foreach(i = 1:N_sims) %dopar% {
require(tidyverse)
require(tmle3)
require(sl3)
require(SuperLearner)
# Initialize dataset
# i<-1
plas_data <- cbind(id = plas_sims$Sim_Data[i],
A = plas_sims$Sim_Data[i + (2*plas_sim_N)],
Y = plas_sims$Sim_Data[i + plas_sim_N])
colnames(plas_data) <- c("id", "A", "Y")
set1 <- suppressMessages(left_join(as_tibble(plas_data), as_tibble(plas))) #dplyr::select(as_tibble(plas), -Y5, -A1))) # add covariates
# mean(set1[which(set1$A==1),]$Y) - mean(set1[which(set1$A==0),]$Y)
#mean(set1[which(set1$A1==1),]$Y) - mean(set1[which(set1$A1==0),]$Y)
tset <- set1 %>% mutate(YT = (Y-min(set1$Y))/(max(set1$Y)- min(set1$Y)))
# set1 <- set1[1:N_samp, ]
# tset <- tset[1:N_samp, ]
getRES(set1, tset, aipw_lib, tmle_lib, short_tmle_lib,
doAIPW=0, doDCAIPW=0,
doIPW = 1,
doTMLE=0, doManuTMLE=0, doShortTMLE = 0,
doDCTMLE=0
)
}
toc()
}
##################################
## SUMMARIZE AND VISUALIZE
##################################
{
tmp <- NULL
for(i in 1:N_sims){
tmp <- rbind(tmp, boot1[[i]])
}
sim_corr1 <- as_tibble(tmp) %>%
mutate(ATE = as.double(ATE), SE = as.double(SE),
lb = as.double(ATE) - 1.96*as.double(SE),
ub = as.double(ATE) + 1.96*as.double(SE)) %>%
add_column(iter = c(1:nrow(tmp))) %>% mutate(bias = as.double(ATE) - Effect_Size)
#write_csv(plas_corr1, paste0(out_path, Sys.Date(), "-plasmode_sim_CV-TMLE_GLM_IPW_1000.csv"))
sim_res <- sim_corr1 %>% group_by(TYPE) %>%
summarize(mu_ATE = mean(ATE), med_ATE = median(ATE),
mu_SE = mean(SE), med_SE = median(SE),
mu_bias = mean(bias), med_bias = median(bias),
var = var(ATE), MSE = var + mu_bias^2,
coverage = sum(lb <= Effect_Size & ub >= Effect_Size)/N_sims)
out_path <- "/Users/garethalex/Desktop/HuangGroup/cvtmle_plasmode/Data/"
boot1.out <- data.frame(matrix(unlist(tmp),ncol=3))
fac.to.num <- function(f) as.numeric(levels(f))[f]
boot1.out[,1:2] <- lapply(boot1.out[,1:2], fac.to.num)
boot1.out %>% group_by(X3)
sim_res
}
{
out_path <- "/Users/garethalex/Desktop/HuangGroup/cvtmle_plasmode/Data/"
plas_org <- haven::read_dta(paste0(out_path,"plas_data.dta"))
vars <- names(plas_org[3:333])
# data.ver <- "FULL"
data.ver <- "13"
size <- 1178
#size <-200
# set.seed(2134)
rm(.Random.seed, envir=.GlobalEnv)
plas <- make.set(ver=data.ver, size = size, plas = plas_org, use.subset=F)
plas.formula <- make.formula("Y5", "A1", ver=data.ver)
outForm <- plas.formula$outForm
expForm <- plas.formula$expForm
plas_sim_N <- 1000
Effect_Size <- 6.6 # simulated risk difference = large change (e.g. absolute units)
#Effect_Size <- 0.66 # simulated risk difference = 2/3 SD higher BMI
source("20200226-PlasmodeCont_Revised.R")
# set.seed(2222)
plas_sims <- PlasmodeContNew(formulaOut = as.formula(outForm), objectOut = NULL,
formulaExp = as.formula(expForm), objectExp = NULL,
data = plas, idVar = "id",
effectOR = Effect_Size, MMOut = 1, MMExp = 1,
nsim = plas_sim_N, size = nrow(plas),
exposedPrev = NULL)
}
#meta_res <- NULL # intialize the results table
source("20200705-DCDR-Functions.R")
source("20200720-Algos-code.R")
##################################
## PARALLELIZE ANALYSES
##################################
{
##########################################
# Initialize necessary parameters for estimator
##########################################
# TMLE parameters
#SL.lib <- c("SL.randomForest", "SL.xgboost", "SL.nnet", "SL.glm", "SL.glmnet", "SL.polymars")
#SL.lib <- list("SL.randomForest", "SL.xgboost", "SL.nnet", "SL.glm", c("SL.glmnet", "All"), c("SL.polymars", "All"))
SL.lib <- list("SL.randomForest", "SL.xgboost", "SL.glm", c("SL.polymars", "All"))
SL.lib.tmle <- c("SL.randomForest", "SL.xgboost", "SL.glm", "SL.polymars")
SL.param <- c("SL.glm", "SL.glmnet", "SL.polymars")
# Specify the NP-SEM for the TMLE - including bounded, tranformed Y ("YT")
Zvars <- ifelse(data.ver=="FULL",
vars,
c("L0.a", "L0.b", "L0.c", "L0.d", "L0.e", "L0.f", "L0.g", "L0.h", "L0.i", "L0.j", "L0.k"))
npsem <- list(define_node("Z", Zvars),
#c("L0.a", "L0.b", "L0.c", "L0.d", "L0.e", "L0.f", "L0.g", "L0.h", "L0.i", "L0.j", "L0.k")),
define_node("A", c("A"), c("Z")),
define_node("Y", c("YT"), c("A", "Z")))
# Specify the learners for CV-TMLE
lrnr_SL <- make_learner(Lrnr_pkg_SuperLearner, SL.lib.tmle)
lrnr_SL_param <- make_learner(Lrnr_pkg_SuperLearner, SL.param)
lrnr_glm <- make_learner(Lrnr_glm_fast)
lrnr_mean <- make_learner(Lrnr_mean)
SL_list <- list(Y = lrnr_SL, A = lrnr_SL)
SL_param_list <- list(Y = lrnr_SL_param, A = lrnr_SL_param)
glm_list <- list(Y = lrnr_glm, A = lrnr_glm)
}
{
set.seed(42782)
tic()
N_sims <- 200# this should <= plas_sim_N
# regression models for GLM / AIPW
reg.formulas <- make.formula("Y", "A",ver = data.ver)
expForm <- reg.formulas$expForm
outForm <- reg.formulas$outForm
# # specify which set of learners for SL
# ### NON-SMOOTH
# short_tmle_lib <- SL_param_list
# tmle_lib <- lrnr_SL
# aipw_lib <- SL.lib
#### SMOOTH
short_tmle_lib <- SL_list
tmle_lib <- lrnr_SL_param
aipw_lib <- SL.param
boot1 <- foreach(i = 1:N_sims) %dopar% {
require(tidyverse)
require(tmle3)
require(sl3)
require(SuperLearner)
# Initialize dataset
# i<-1
plas_data <- cbind(id = plas_sims$Sim_Data[i],
A = plas_sims$Sim_Data[i + (2*plas_sim_N)],
Y = plas_sims$Sim_Data[i + plas_sim_N])
colnames(plas_data) <- c("id", "A", "Y")
set1 <- suppressMessages(left_join(as_tibble(plas_data), as_tibble(plas))) #dplyr::select(as_tibble(plas), -Y5, -A1))) # add covariates
# mean(set1[which(set1$A==1),]$Y) - mean(set1[which(set1$A==0),]$Y)
#mean(set1[which(set1$A1==1),]$Y) - mean(set1[which(set1$A1==0),]$Y)
tset <- set1 %>% mutate(YT = (Y-min(set1$Y))/(max(set1$Y)- min(set1$Y)))
# set1 <- set1[1:N_samp, ]
# tset <- tset[1:N_samp, ]
getRES(set1, tset, aipw_lib, tmle_lib, short_tmle_lib,
doAIPW=0, doDCAIPW=0,
doIPW = 1,
doTMLE=0, doManuTMLE=0, doShortTMLE = 0,
doDCTMLE=0
)
}
toc()
}
##################################
## SUMMARIZE AND VISUALIZE
##################################
{
tmp <- NULL
for(i in 1:N_sims){
tmp <- rbind(tmp, boot1[[i]])
}
sim_corr1 <- as_tibble(tmp) %>%
mutate(ATE = as.double(ATE), SE = as.double(SE),
lb = as.double(ATE) - 1.96*as.double(SE),
ub = as.double(ATE) + 1.96*as.double(SE)) %>%
add_column(iter = c(1:nrow(tmp))) %>% mutate(bias = as.double(ATE) - Effect_Size)
#write_csv(plas_corr1, paste0(out_path, Sys.Date(), "-plasmode_sim_CV-TMLE_GLM_IPW_1000.csv"))
sim_res <- sim_corr1 %>% group_by(TYPE) %>%
summarize(mu_ATE = mean(ATE), med_ATE = median(ATE),
mu_SE = mean(SE), med_SE = median(SE),
mu_bias = mean(bias), med_bias = median(bias),
var = var(ATE), MSE = var + mu_bias^2,
coverage = sum(lb <= Effect_Size & ub >= Effect_Size)/N_sims)
out_path <- "/Users/garethalex/Desktop/HuangGroup/cvtmle_plasmode/Data/"
boot1.out <- data.frame(matrix(unlist(tmp),ncol=3))
fac.to.num <- function(f) as.numeric(levels(f))[f]
boot1.out[,1:2] <- lapply(boot1.out[,1:2], fac.to.num)
boot1.out %>% group_by(X3)
sim_res
}
{
out_path <- "/Users/garethalex/Desktop/HuangGroup/cvtmle_plasmode/Data/"
plas_org <- haven::read_dta(paste0(out_path,"plas_data.dta"))
vars <- names(plas_org[3:333])
# data.ver <- "FULL"
data.ver <- "13"
size <- 1178
#size <-200
# set.seed(2134)
rm(.Random.seed, envir=.GlobalEnv)
plas <- make.set(ver=data.ver, size = size, plas = plas_org, use.subset=F)
plas.formula <- make.formula("Y5", "A1", ver=data.ver)
outForm <- plas.formula$outForm
expForm <- plas.formula$expForm
plas_sim_N <- 1000
Effect_Size <- 6.6 # simulated risk difference = large change (e.g. absolute units)
#Effect_Size <- 0.66 # simulated risk difference = 2/3 SD higher BMI
source("20200226-PlasmodeCont_Revised.R")
set.seed(2222)
plas_sims <- PlasmodeContNew(formulaOut = as.formula(outForm), objectOut = NULL,
formulaExp = as.formula(expForm), objectExp = NULL,
data = plas, idVar = "id",
effectOR = Effect_Size, MMOut = 1, MMExp = 1,
nsim = plas_sim_N, size = nrow(plas),
exposedPrev = NULL)
}
#meta_res <- NULL # intialize the results table
source("20200705-DCDR-Functions.R")
source("20200720-Algos-code.R")
##################################
## PARALLELIZE ANALYSES
##################################
{
##########################################
# Initialize necessary parameters for estimator
##########################################
# TMLE parameters
#SL.lib <- c("SL.randomForest", "SL.xgboost", "SL.nnet", "SL.glm", "SL.glmnet", "SL.polymars")
#SL.lib <- list("SL.randomForest", "SL.xgboost", "SL.nnet", "SL.glm", c("SL.glmnet", "All"), c("SL.polymars", "All"))
SL.lib <- list("SL.randomForest", "SL.xgboost", "SL.glm", c("SL.polymars", "All"))
SL.lib.tmle <- c("SL.randomForest", "SL.xgboost", "SL.glm", "SL.polymars")
SL.param <- c("SL.glm", "SL.glmnet", "SL.polymars")
# Specify the NP-SEM for the TMLE - including bounded, tranformed Y ("YT")
Zvars <- ifelse(data.ver=="FULL",
vars,
c("L0.a", "L0.b", "L0.c", "L0.d", "L0.e", "L0.f", "L0.g", "L0.h", "L0.i", "L0.j", "L0.k"))
npsem <- list(define_node("Z", Zvars),
#c("L0.a", "L0.b", "L0.c", "L0.d", "L0.e", "L0.f", "L0.g", "L0.h", "L0.i", "L0.j", "L0.k")),
define_node("A", c("A"), c("Z")),
define_node("Y", c("YT"), c("A", "Z")))
# Specify the learners for CV-TMLE
lrnr_SL <- make_learner(Lrnr_pkg_SuperLearner, SL.lib.tmle)
lrnr_SL_param <- make_learner(Lrnr_pkg_SuperLearner, SL.param)
lrnr_glm <- make_learner(Lrnr_glm_fast)
lrnr_mean <- make_learner(Lrnr_mean)
SL_list <- list(Y = lrnr_SL, A = lrnr_SL)
SL_param_list <- list(Y = lrnr_SL_param, A = lrnr_SL_param)
glm_list <- list(Y = lrnr_glm, A = lrnr_glm)
}
{
set.seed(42782)
tic()
N_sims <- 200# this should <= plas_sim_N
# regression models for GLM / AIPW
reg.formulas <- make.formula("Y", "A",ver = data.ver)
expForm <- reg.formulas$expForm
outForm <- reg.formulas$outForm
# # specify which set of learners for SL
# ### NON-SMOOTH
# short_tmle_lib <- SL_param_list
# tmle_lib <- lrnr_SL
# aipw_lib <- SL.lib
#### SMOOTH
short_tmle_lib <- SL_list
tmle_lib <- lrnr_SL_param
aipw_lib <- SL.param
boot1 <- foreach(i = 1:N_sims) %dopar% {
require(tidyverse)
require(tmle3)
require(sl3)
require(SuperLearner)
# Initialize dataset
# i<-1
plas_data <- cbind(id = plas_sims$Sim_Data[i],
A = plas_sims$Sim_Data[i + (2*plas_sim_N)],
Y = plas_sims$Sim_Data[i + plas_sim_N])
colnames(plas_data) <- c("id", "A", "Y")
set1 <- suppressMessages(left_join(as_tibble(plas_data), as_tibble(plas))) #dplyr::select(as_tibble(plas), -Y5, -A1))) # add covariates
# mean(set1[which(set1$A==1),]$Y) - mean(set1[which(set1$A==0),]$Y)
#mean(set1[which(set1$A1==1),]$Y) - mean(set1[which(set1$A1==0),]$Y)
tset <- set1 %>% mutate(YT = (Y-min(set1$Y))/(max(set1$Y)- min(set1$Y)))
# set1 <- set1[1:N_samp, ]
# tset <- tset[1:N_samp, ]
getRES(set1, tset, aipw_lib, tmle_lib, short_tmle_lib,
doAIPW=0, doDCAIPW=0,
doIPW = 1,
doTMLE=0, doManuTMLE=0, doShortTMLE = 0,
doDCTMLE=0
)
}
toc()
}
##################################
## SUMMARIZE AND VISUALIZE
##################################
{
tmp <- NULL
for(i in 1:N_sims){
tmp <- rbind(tmp, boot1[[i]])
}
sim_corr1 <- as_tibble(tmp) %>%
mutate(ATE = as.double(ATE), SE = as.double(SE),
lb = as.double(ATE) - 1.96*as.double(SE),
ub = as.double(ATE) + 1.96*as.double(SE)) %>%
add_column(iter = c(1:nrow(tmp))) %>% mutate(bias = as.double(ATE) - Effect_Size)
#write_csv(plas_corr1, paste0(out_path, Sys.Date(), "-plasmode_sim_CV-TMLE_GLM_IPW_1000.csv"))
sim_res <- sim_corr1 %>% group_by(TYPE) %>%
summarize(mu_ATE = mean(ATE), med_ATE = median(ATE),
mu_SE = mean(SE), med_SE = median(SE),
mu_bias = mean(bias), med_bias = median(bias),
var = var(ATE), MSE = var + mu_bias^2,
coverage = sum(lb <= Effect_Size & ub >= Effect_Size)/N_sims)
out_path <- "/Users/garethalex/Desktop/HuangGroup/cvtmle_plasmode/Data/"
boot1.out <- data.frame(matrix(unlist(tmp),ncol=3))
fac.to.num <- function(f) as.numeric(levels(f))[f]
boot1.out[,1:2] <- lapply(boot1.out[,1:2], fac.to.num)
boot1.out %>% group_by(X3)
sim_res
}
{
out_path <- "/Users/garethalex/Desktop/HuangGroup/cvtmle_plasmode/Data/"
plas_org <- haven::read_dta(paste0(out_path,"plas_data.dta"))
vars <- names(plas_org[3:333])
# data.ver <- "FULL"
data.ver <- "13"
size <- 1178
#size <-200
# set.seed(2134)
rm(.Random.seed, envir=.GlobalEnv)
plas <- make.set(ver=data.ver, size = size, plas = plas_org, use.subset=F)
plas.formula <- make.formula("Y5", "A1", ver=data.ver)
outForm <- plas.formula$outForm
expForm <- plas.formula$expForm
plas_sim_N <- 1000
Effect_Size <- 6.6 # simulated risk difference = large change (e.g. absolute units)
#Effect_Size <- 0.66 # simulated risk difference = 2/3 SD higher BMI
source("20200226-PlasmodeCont_Revised.R")
set.seed(2222)
plas_sims <- PlasmodeContNew(formulaOut = as.formula(outForm), objectOut = NULL,
formulaExp = as.formula(expForm), objectExp = NULL,
data = plas, idVar = "id",
effectOR = Effect_Size, MMOut = 1, MMExp = 1,
nsim = plas_sim_N, size = nrow(plas),
exposedPrev = NULL)
}
#meta_res <- NULL # intialize the results table
source("20200705-DCDR-Functions.R")
source("20200720-Algos-code.R")
##################################
## PARALLELIZE ANALYSES
##################################
{
##########################################
# Initialize necessary parameters for estimator
##########################################
# TMLE parameters
#SL.lib <- c("SL.randomForest", "SL.xgboost", "SL.nnet", "SL.glm", "SL.glmnet", "SL.polymars")
#SL.lib <- list("SL.randomForest", "SL.xgboost", "SL.nnet", "SL.glm", c("SL.glmnet", "All"), c("SL.polymars", "All"))
SL.lib <- list("SL.randomForest", "SL.xgboost", "SL.glm", c("SL.polymars", "All"))
SL.lib.tmle <- c("SL.randomForest", "SL.xgboost", "SL.glm", "SL.polymars")
SL.param <- c("SL.glm", "SL.glmnet", "SL.polymars")
# Specify the NP-SEM for the TMLE - including bounded, tranformed Y ("YT")
Zvars <- ifelse(data.ver=="FULL",
vars,
c("L0.a", "L0.b", "L0.c", "L0.d", "L0.e", "L0.f", "L0.g", "L0.h", "L0.i", "L0.j", "L0.k"))
npsem <- list(define_node("Z", Zvars),
#c("L0.a", "L0.b", "L0.c", "L0.d", "L0.e", "L0.f", "L0.g", "L0.h", "L0.i", "L0.j", "L0.k")),
define_node("A", c("A"), c("Z")),
define_node("Y", c("YT"), c("A", "Z")))
# Specify the learners for CV-TMLE
lrnr_SL <- make_learner(Lrnr_pkg_SuperLearner, SL.lib.tmle)
lrnr_SL_param <- make_learner(Lrnr_pkg_SuperLearner, SL.param)
lrnr_glm <- make_learner(Lrnr_glm_fast)
lrnr_mean <- make_learner(Lrnr_mean)
SL_list <- list(Y = lrnr_SL, A = lrnr_SL)
SL_param_list <- list(Y = lrnr_SL_param, A = lrnr_SL_param)
glm_list <- list(Y = lrnr_glm, A = lrnr_glm)
}
{
set.seed(42782)
tic()
N_sims <- 200# this should <= plas_sim_N
# regression models for GLM / AIPW
reg.formulas <- make.formula("Y", "A",ver = data.ver)
expForm <- reg.formulas$expForm
outForm <- reg.formulas$outForm
# # specify which set of learners for SL
# ### NON-SMOOTH
# short_tmle_lib <- SL_param_list
# tmle_lib <- lrnr_SL
# aipw_lib <- SL.lib
#### SMOOTH
short_tmle_lib <- SL_list
tmle_lib <- lrnr_SL_param
aipw_lib <- SL.param
boot1 <- foreach(i = 1:N_sims) %dopar% {
require(tidyverse)
require(tmle3)
require(sl3)
require(SuperLearner)
# Initialize dataset
# i<-1
plas_data <- cbind(id = plas_sims$Sim_Data[i],
A = plas_sims$Sim_Data[i + (2*plas_sim_N)],
Y = plas_sims$Sim_Data[i + plas_sim_N])
colnames(plas_data) <- c("id", "A", "Y")
set1 <- suppressMessages(left_join(as_tibble(plas_data), as_tibble(plas))) #dplyr::select(as_tibble(plas), -Y5, -A1))) # add covariates
# mean(set1[which(set1$A==1),]$Y) - mean(set1[which(set1$A==0),]$Y)
#mean(set1[which(set1$A1==1),]$Y) - mean(set1[which(set1$A1==0),]$Y)
tset <- set1 %>% mutate(YT = (Y-min(set1$Y))/(max(set1$Y)- min(set1$Y)))
# set1 <- set1[1:N_samp, ]
# tset <- tset[1:N_samp, ]
getRES(set1, tset, aipw_lib, tmle_lib, short_tmle_lib,
doAIPW=0, doDCAIPW=0,
doIPW = 1,
doTMLE=0, doManuTMLE=0, doShortTMLE = 0,
doDCTMLE=0
)
}
toc()
}
##################################
## SUMMARIZE AND VISUALIZE
##################################
{
tmp <- NULL
for(i in 1:N_sims){
tmp <- rbind(tmp, boot1[[i]])
}
sim_corr1 <- as_tibble(tmp) %>%
mutate(ATE = as.double(ATE), SE = as.double(SE),
lb = as.double(ATE) - 1.96*as.double(SE),
ub = as.double(ATE) + 1.96*as.double(SE)) %>%
add_column(iter = c(1:nrow(tmp))) %>% mutate(bias = as.double(ATE) - Effect_Size)
#write_csv(plas_corr1, paste0(out_path, Sys.Date(), "-plasmode_sim_CV-TMLE_GLM_IPW_1000.csv"))
sim_res <- sim_corr1 %>% group_by(TYPE) %>%
summarize(mu_ATE = mean(ATE), med_ATE = median(ATE),
mu_SE = mean(SE), med_SE = median(SE),
mu_bias = mean(bias), med_bias = median(bias),
var = var(ATE), MSE = var + mu_bias^2,
coverage = sum(lb <= Effect_Size & ub >= Effect_Size)/N_sims)
out_path <- "/Users/garethalex/Desktop/HuangGroup/cvtmle_plasmode/Data/"
boot1.out <- data.frame(matrix(unlist(tmp),ncol=3))
fac.to.num <- function(f) as.numeric(levels(f))[f]
boot1.out[,1:2] <- lapply(boot1.out[,1:2], fac.to.num)
boot1.out %>% group_by(X3)
sim_res
}
