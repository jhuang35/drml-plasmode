length(y)
##### Create dataframe with basic time features
d = data.frame(Time = v_time, y)
d$Year = as.integer(strftime(v_time,'%Y'))
d$Month = as.integer(strftime(v_time,'%m'))
##### Basic Univariate Plots
plot(y)
seasonplot(y) #look for consistency in peak/offpeak
#look at annual data to better see smooth trend
d_yr = aggregate(data = d, y ~ Year, sum  )
#look at annual data to better see smooth trend
d_yr = aggregate(data = d, y ~ Year, sum  )
= aggregate(data = d, y ~ Year, sum  )
d_yr
ts.plot(d_yr$y)
v_yr = sort(unique(d$Year))
#check if monthly proportions roughly look constant year-to-year
colnames(d_yr)[2] = "y_annual"
d = merge(d, d_yr, by = "Year")
d_yr
d$y_prop
d
d$y_prop = d$y/d$y_annual
ts.plot(d$y_prop)
#Look at distribution in monthly proportions (assuming stationary)
boxplot(data = d, y_prop ~ Month) ##check similarity in proportions
##### STL Decompostion
#given seasonal effect depends on level do log transform
y_log = log(y)
#decompose and plot
fit_stl = stl(y_log, s.window = 12)
plot(fit_stl)
#extract components
S = fit_stl$time.series[,1]
L = fit_stl$time.series[,2]
E = fit_stl$time.series[,3]
ts.plot(exp(S), main = 'Multiplicative Seasonality Component')
##### Functional Data View of Seasonality
#convert univariate series to 12 curves for each year
M = matrix(NA, nrow = 12, ncol =  length(v_yr) )
d$S = exp(S)
##### Functional Data View of Seasonality
#convert univariate series to 12 curves for each year
M = matrix(NA, nrow = 12, ncol =  length(v_yr) )
v_yr
d$S = exp(S)
for( j in 1:ncol(M)  ){
#subset
d_j = subset(d, Year == v_yr[j])
S_j = d_j$S
S_j = S_j/mean(S_j) #ensure normalized
#add
M[,j] = S_j
}
colnames(M) = v_yr
#Add Fourier Bases and plot
v_f <- create.fourier.basis(  rangeval = c(0,nrow(M)),  nbasis = 7)
S_basis <- smooth.basis( y = M, fdParobj = v_f)
plot(S_basis$fd)
data(Collage)
data(College)
M
subset(d, Year == v_yr[j])
plot(fit_stl)
S_j = d_j$S
mean(S_j)
#Add Fourier Bases and plot
v_f <- create.fourier.basis(  rangeval = c(0,nrow(M)),  nbasis = 7)
S_basis <- smooth.basis( y = M, fdParobj = v_f)
plot(S_basis$fd)
#Add mean
W.mean <- mean.fd(S_basis$fd)
lines(W.mean, lty = 2, col='black', lwd=3)
##### Look at Multiplicative Residuals
#plot centered about zero to eyeball randomness
ts.plot(E)
tSeq = 1:length(E)
abline(h=0, col='black')
#autocorrelation
acf(E)
#control chart at slow smoothing
ewma(E, lambda = .1)
#fit ar(1) model and extract residuals
fit_ar1 = arima(E, order = c(1,0,0))
r = fit_ar1$residuals
r = r/sd(r)
#distribution
hist(r, main='Frequency of Normalized Multiplicative Residuals')
#compare fit against standard Gaussian
qqPlot(r, main='Normalized Multiplicative Residuals vs N(0,1)')
?plas
library(Plasmode)
?plas
n <- 100
x <- rbinom(n,p=0.25)
x <- rbinom(size=n,p=0.25)
x <- rbinom(n,size=1,p=0.25)
hist(x)
x
x <- rbinom(n,size=30,p=0.25)
hist(x)
hist(x/30)
x <- rbinom(n,size=300,p=0.25)
hist(x/300)
n <- 1000
x <- rbinom(n,size=300,p=0.25)
hist(x/300)
hist(x/300,xlim=c(0,1))
n <- 100
x <- rbinom(n,size=300,p=0.25)
hist(x/300,xlim=c(0,1))
n <- 10
x <- rbinom(n,size=300,p=0.25)
hist(x/300,xlim=c(0,1))
n <- 100
x <- rbinom(n,size=300,p=0.25)
hist(x/300,xlim=c(0,1))
hist(x/300)
pnorm(0.975)
p\qnorm(0.975)
qnorm(0.975)
getwd()
x<-c(46,47,45,45,47)
var(x)
?t.test
1.5+4.63*4 + 6.45*8+0.022*237
1.5+4.63*4 + 6.45*8+0.022*300
library(tidyverse)
library(ggplot2)
library(haven)
library(readxl)
library(table1)
library(ggbeeswarm)
library(ltmle)
library(Plasmode)
library(SuperLearner)
library(ctmle)
library(sl3)
library(tmle3)
library(tictoc)
library(doParallel)
library(doRNG)
library(foreach)
library(randomForest)
# require(purrr)
# require(furrr)
setwd("~/Desktop/HuangGroup/cvtmle_plasmode/Code")
set.seed(42782)
options(tibble.print_max = 40, tibble.print_min = 30)
registerDoParallel(cores=detectCores(all.tests = T)-2)
# Set simulation parameters
{
sims.ver <- "plas"
# sims.ver <- "5var"
# sims.ver <- "5var.then.plas"
Effect_Size <- 6.6
plas.seed <- 2222
########
# parameters for plasmode
#######
# data.ver <- "FULL"
data.ver <- "13"
# size <- 1178
size <-200
plas_sim_N <- 500; use.subset <- F
generateA <- F
########
# parameters for 5 var, 5var.then.plas
#######
# Nsets <- 10000
# Nsamp <- 3000
Nsets <- 500
Nsamp <- 600
}
source("20200803-Sims-Function.R")
cat(sims.ver)
sims.obj <- general.sim(sims.ver)
function (path)
# Set simulation parameters
{
sims.ver <- "plas"
# sims.ver <- "5var"
# sims.ver <- "5var.then.plas"
Effect_Size <- 6.6
plas.seed <- 2222
########
# parameters for plasmode
#######
# data.ver <- "FULL"
data.ver <- "13"
# size <- 1178
size <-200
plas_sim_N <- 500; use.subset <- F
generateA <- F
########
# parameters for 5 var, 5var.then.plas
#######
# Nsets <- 10000
# Nsamp <- 3000
Nsets <- 500
Nsamp <- 600
}
source("20200803-Sims-Function.R")
cat(sims.ver)
sims.obj <- general.sim(sims.ver)
source("20200803-Sims-Function.R")
cat(sims.ver)
sims.obj <- general.sim(sims.ver)
if (sims.ver == "plas"|sims.ver == "5var.then.plas"){
plas <- sims.obj$plas
plas_sims <- sims.obj$plas_sims
}else{
sim_boots <- sims.obj
}
# DC implementation
source("20200705-DCDR-Functions.R")
# getRES function is now relocated to a separate file (20200720-Algos-code.R)
source("20200720-Algos-code.R")
# Set simulation parameters
{
sims.ver <- "plas"
# sims.ver <- "5var"
# sims.ver <- "5var.then.plas"
Effect_Size <- 6.6
plas.seed <- 2222
########
# parameters for plasmode
#######
# data.ver <- "FULL"
data.ver <- "13"
size <- 1178
# size <-200
plas_sim_N <- 500; use.subset <- F
generateA <- F
########
# parameters for 5 var, 5var.then.plas
#######
# Nsets <- 10000
# Nsamp <- 3000
Nsets <- 500
Nsamp <- 600
}
source("20200803-Sims-Function.R")
cat(sims.ver)
sims.obj <- general.sim(sims.ver)
if (sims.ver == "plas"|sims.ver == "5var.then.plas"){
plas <- sims.obj$plas
plas_sims <- sims.obj$plas_sims
}else{
sim_boots <- sims.obj
}
# DC implementation
source("20200705-DCDR-Functions.R")
# getRES function is now relocated to a separate file (20200720-Algos-code.R)
source("20200720-Algos-code.R")
{
set.seed(42782)
tic()
N_sims <- 100 # this should <= plas_sim_N
# regression models for GLM / AIPW
reg.formulas <- make.formula("Y", "A",ver = data.ver,sims.ver = sims.ver)
expForm <- reg.formulas$expForm
outForm <- reg.formulas$outForm
# specify which set of learners for SL
### NON-SMOOTH
short_tmle_lib <- SL_param_list
tmle_lib <- lrnr_SL
aipw_lib <- SL.lib
#
# # SMOOTH
# short_tmle_lib <- SL_list
# tmle_lib <- lrnr_SL_param
# aipw_lib <- SL.param
# set .errorhandling="remove" if want to discard
# set .errorhandling="stop" by default
# boot1 <- foreach(i = 1:N_sims,.errorhandling="stop") %dopar% {
boot1 <- foreach(i = 1:N_sims,.errorhandling="remove") %dopar% {
require(tidyverse)
require(tmle3)
require(sl3)
require(SuperLearner)
# Initialize dataset
# i<-10 # DEBUG
if (sims.ver == "plas" | sims.ver =="5var.then.plas"){
# i <- 1
plas_data <- cbind(id = plas_sims$Sim_Data[i],
A = plas_sims$Sim_Data[i + (2*plas_sim_N)],
Y = plas_sims$Sim_Data[i + plas_sim_N])
colnames(plas_data) <- c("id", "A", "Y")
set1 <- suppressMessages(left_join(as_tibble(plas_data), as_tibble(plas))) #dplyr::select(as_tibble(plas), -Y5, -A1))) # add covariates
tset <- set1 %>% mutate(YT = (Y-min(set1$Y))/(max(set1$Y)- min(set1$Y)))
}else{
# Initialize dataset
# i<-2
ss <- 600
set1 <- as_tibble(cbind(C1 = sim_boots[[i]]$C1[1:ss],
C2 = sim_boots[[i]]$C2[1:ss],
C3 = sim_boots[[i]]$C3[1:ss],
C4 = sim_boots[[i]]$C4[1:ss],
C5 = sim_boots[[i]]$C5[1:ss],
A = sim_boots[[i]]$A[1:ss],
Y = sim_boots[[i]]$Y[1:ss]))
tset <- set1 %>% mutate(YT = (Y-min(set1$Y))/(max(set1$Y)- min(set1$Y))) # generate a bounded Y for TMLE
}
getRES(set1, tset, aipw_lib, tmle_lib, short_tmle_lib,
doIPW = 0,
doAIPW=0, doDCAIPW=0,
doManuTMLE=1, doShortTMLE = 0,
doDCTMLE=0,
num_cf=5,
#control=list()
control=SuperLearner.CV.control(V=2)
)
}
toc()
}
{
set.seed(42782)
tic()
N_sims <- 100 # this should <= plas_sim_N
# regression models for GLM / AIPW
reg.formulas <- make.formula("Y", "A",ver = data.ver,sims.ver = sims.ver)
expForm <- reg.formulas$expForm
outForm <- reg.formulas$outForm
# specify which set of learners for SL
# ### NON-SMOOTH
# short_tmle_lib <- SL_param_list
# tmle_lib <- lrnr_SL
# aipw_lib <- SL.lib
#
# SMOOTH
short_tmle_lib <- SL_list
tmle_lib <- lrnr_SL_param
aipw_lib <- SL.param
# set .errorhandling="remove" if want to discard
# set .errorhandling="stop" by default
# boot1 <- foreach(i = 1:N_sims,.errorhandling="stop") %dopar% {
boot1 <- foreach(i = 1:N_sims,.errorhandling="remove") %dopar% {
require(tidyverse)
require(tmle3)
require(sl3)
require(SuperLearner)
# Initialize dataset
# i<-10 # DEBUG
if (sims.ver == "plas" | sims.ver =="5var.then.plas"){
# i <- 1
plas_data <- cbind(id = plas_sims$Sim_Data[i],
A = plas_sims$Sim_Data[i + (2*plas_sim_N)],
Y = plas_sims$Sim_Data[i + plas_sim_N])
colnames(plas_data) <- c("id", "A", "Y")
set1 <- suppressMessages(left_join(as_tibble(plas_data), as_tibble(plas))) #dplyr::select(as_tibble(plas), -Y5, -A1))) # add covariates
tset <- set1 %>% mutate(YT = (Y-min(set1$Y))/(max(set1$Y)- min(set1$Y)))
}else{
# Initialize dataset
# i<-2
ss <- 600
set1 <- as_tibble(cbind(C1 = sim_boots[[i]]$C1[1:ss],
C2 = sim_boots[[i]]$C2[1:ss],
C3 = sim_boots[[i]]$C3[1:ss],
C4 = sim_boots[[i]]$C4[1:ss],
C5 = sim_boots[[i]]$C5[1:ss],
A = sim_boots[[i]]$A[1:ss],
Y = sim_boots[[i]]$Y[1:ss]))
tset <- set1 %>% mutate(YT = (Y-min(set1$Y))/(max(set1$Y)- min(set1$Y))) # generate a bounded Y for TMLE
}
getRES(set1, tset, aipw_lib, tmle_lib, short_tmle_lib,
doIPW = 1,
doAIPW=0, doDCAIPW=0,
doManuTMLE=0, doShortTMLE = 0,
doDCTMLE=0,
num_cf=5,
#control=list()
control=SuperLearner.CV.control(V=2)
)
}
toc()
}
(N_boot <- length(boot1))
##################################
## SUMMARIZE AND VISUALIZE
##################################
source("20200816-Result-Summary.R")
cat("plas.seed=",plas.seed, "generateA=",generateA, "sims.ver=",sims.ver)
pdf("xxx.pdf",width=7,height = 5)
dev.off()
summarise.res(boot1)
# Set simulation parameters
{
sims.ver <- "plas"
# sims.ver <- "5var"
# sims.ver <- "5var.then.plas"
Effect_Size <- 6.6
plas.seed <- 2222
########
# parameters for plasmode
#######
data.ver <- "FULL"
# data.ver <- "13"
size <- 1178
# size <-200
plas_sim_N <- 500; use.subset <- F
generateA <- F
########
# parameters for 5 var, 5var.then.plas
#######
# Nsets <- 10000
# Nsamp <- 3000
Nsets <- 500
Nsamp <- 600
}
source("20200803-Sims-Function.R")
cat(sims.ver)
sims.obj <- general.sim(sims.ver)
if (sims.ver == "plas"|sims.ver == "5var.then.plas"){
plas <- sims.obj$plas
plas_sims <- sims.obj$plas_sims
}else{
sim_boots <- sims.obj
}
# DC implementation
source("20200705-DCDR-Functions.R")
# getRES function is now relocated to a separate file (20200720-Algos-code.R)
source("20200720-Algos-code.R")
{
set.seed(42782)
tic()
N_sims <- 100 # this should <= plas_sim_N
# regression models for GLM / AIPW
reg.formulas <- make.formula("Y", "A",ver = data.ver,sims.ver = sims.ver)
expForm <- reg.formulas$expForm
outForm <- reg.formulas$outForm
# specify which set of learners for SL
# ### NON-SMOOTH
# short_tmle_lib <- SL_param_list
# tmle_lib <- lrnr_SL
# aipw_lib <- SL.lib
#
# SMOOTH
short_tmle_lib <- SL_list
tmle_lib <- lrnr_SL_param
aipw_lib <- SL.param
# set .errorhandling="remove" if want to discard
# set .errorhandling="stop" by default
# boot1 <- foreach(i = 1:N_sims,.errorhandling="stop") %dopar% {
boot1 <- foreach(i = 1:N_sims,.errorhandling="remove") %dopar% {
require(tidyverse)
require(tmle3)
require(sl3)
require(SuperLearner)
# Initialize dataset
# i<-10 # DEBUG
if (sims.ver == "plas" | sims.ver =="5var.then.plas"){
# i <- 1
plas_data <- cbind(id = plas_sims$Sim_Data[i],
A = plas_sims$Sim_Data[i + (2*plas_sim_N)],
Y = plas_sims$Sim_Data[i + plas_sim_N])
colnames(plas_data) <- c("id", "A", "Y")
set1 <- suppressMessages(left_join(as_tibble(plas_data), as_tibble(plas))) #dplyr::select(as_tibble(plas), -Y5, -A1))) # add covariates
tset <- set1 %>% mutate(YT = (Y-min(set1$Y))/(max(set1$Y)- min(set1$Y)))
}else{
# Initialize dataset
# i<-2
ss <- 600
set1 <- as_tibble(cbind(C1 = sim_boots[[i]]$C1[1:ss],
C2 = sim_boots[[i]]$C2[1:ss],
C3 = sim_boots[[i]]$C3[1:ss],
C4 = sim_boots[[i]]$C4[1:ss],
C5 = sim_boots[[i]]$C5[1:ss],
A = sim_boots[[i]]$A[1:ss],
Y = sim_boots[[i]]$Y[1:ss]))
tset <- set1 %>% mutate(YT = (Y-min(set1$Y))/(max(set1$Y)- min(set1$Y))) # generate a bounded Y for TMLE
}
getRES(set1, tset, aipw_lib, tmle_lib, short_tmle_lib,
doIPW = 1,
doAIPW=0, doDCAIPW=0,
doManuTMLE=0, doShortTMLE = 0,
doDCTMLE=0,
num_cf=5,
#control=list()
control=SuperLearner.CV.control(V=2)
)
}
toc()
}
function (..., collapse = NULL)
# Set simulation parameters
{
sims.ver <- "plas"
# sims.ver <- "5var"
# sims.ver <- "5var.then.plas"
Effect_Size <- 6.6
plas.seed <- 2222
########
# parameters for plasmode
#######
data.ver <- "FULL"
# data.ver <- "13"
size <- 1178
# size <-200
plas_sim_N <- 500; use.subset <- F
generateA <- F
########
# parameters for 5 var, 5var.then.plas
#######
# Nsets <- 10000
# Nsamp <- 3000
Nsets <- 500
Nsamp <- 600
}
source("20200803-Sims-Function.R")
cat(sims.ver)
sims.obj <- general.sim(sims.ver)
